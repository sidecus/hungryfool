<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker Cache Mount - uv as an Example | A Hungry Fool</title><meta name=keywords content="docker,devcontainers"><meta name=description content="Docker‚Äôs cache mount (--mount=type=cache) looks simple on the surface, but it hides an important mental model that often trips people up‚Äîespecially when mixing root vs non-root users, different home directories, or multi-stage builds.
This post explains how cache mounts actually work, why they don‚Äôt share by default, and how to correctly share them, using uv cache as a concrete example.

How Cache Mount Actually Works
Consider this Dockerfile instruction:
RUN --mount=type=cache,target=/root/.cache/uv \
    uv sync
When Docker executes this, it creates a named cache volume. The cache is keyed by:"><meta name=author content="sidecus"><link rel=canonical href=https://www.hungryfool.net/posts/docker-cache-mount---uv-as-an-example/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://www.hungryfool.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.hungryfool.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.hungryfool.net/favicon-32x32.png><link rel=apple-touch-icon href=https://www.hungryfool.net/apple-touch-icon.png><link rel=mask-icon href=https://www.hungryfool.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.hungryfool.net/posts/docker-cache-mount---uv-as-an-example/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VCJZS04E4K"></script><script>var dnt,doNotTrack=!1;if(!0&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VCJZS04E4K")}</script><meta property="og:url" content="https://www.hungryfool.net/posts/docker-cache-mount---uv-as-an-example/"><meta property="og:site_name" content="A Hungry Fool"><meta property="og:title" content="Docker Cache Mount - uv as an Example"><meta property="og:description" content="Docker‚Äôs cache mount (--mount=type=cache) looks simple on the surface, but it hides an important mental model that often trips people up‚Äîespecially when mixing root vs non-root users, different home directories, or multi-stage builds.
This post explains how cache mounts actually work, why they don‚Äôt share by default, and how to correctly share them, using uv cache as a concrete example.
How Cache Mount Actually Works Consider this Dockerfile instruction:
RUN --mount=type=cache,target=/root/.cache/uv \ uv sync When Docker executes this, it creates a named cache volume. The cache is keyed by:"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-15T17:44:20+08:00"><meta property="article:modified_time" content="2025-12-15T17:44:20+08:00"><meta property="article:tag" content="Docker"><meta property="article:tag" content="Devcontainers"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker Cache Mount - uv as an Example"><meta name=twitter:description content="Docker‚Äôs cache mount (--mount=type=cache) looks simple on the surface, but it hides an important mental model that often trips people up‚Äîespecially when mixing root vs non-root users, different home directories, or multi-stage builds.
This post explains how cache mounts actually work, why they don‚Äôt share by default, and how to correctly share them, using uv cache as a concrete example.

How Cache Mount Actually Works
Consider this Dockerfile instruction:
RUN --mount=type=cache,target=/root/.cache/uv \
    uv sync
When Docker executes this, it creates a named cache volume. The cache is keyed by:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.hungryfool.net/posts/"},{"@type":"ListItem","position":2,"name":"Docker Cache Mount - uv as an Example","item":"https://www.hungryfool.net/posts/docker-cache-mount---uv-as-an-example/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker Cache Mount - uv as an Example","name":"Docker Cache Mount - uv as an Example","description":"Docker‚Äôs cache mount (--mount=type=cache) looks simple on the surface, but it hides an important mental model that often trips people up‚Äîespecially when mixing root vs non-root users, different home directories, or multi-stage builds.\nThis post explains how cache mounts actually work, why they don‚Äôt share by default, and how to correctly share them, using uv cache as a concrete example.\nHow Cache Mount Actually Works Consider this Dockerfile instruction:\nRUN --mount=type=cache,target=/root/.cache/uv \\ uv sync When Docker executes this, it creates a named cache volume. The cache is keyed by:\n","keywords":["docker","devcontainers"],"articleBody":"Docker‚Äôs cache mount (--mount=type=cache) looks simple on the surface, but it hides an important mental model that often trips people up‚Äîespecially when mixing root vs non-root users, different home directories, or multi-stage builds.\nThis post explains how cache mounts actually work, why they don‚Äôt share by default, and how to correctly share them, using uv cache as a concrete example.\nHow Cache Mount Actually Works Consider this Dockerfile instruction:\nRUN --mount=type=cache,target=/root/.cache/uv \\ uv sync When Docker executes this, it creates a named cache volume. The cache is keyed by:\nThe builder instance The target path (/root/.cache/uv) An optional cache ID (if you provide one) Now compare it with:\nRUN --mount=type=cache,target=/home/vscode/.cache/uv \\ uv sync Even if:\nit‚Äôs the same Dockerfile same base image same machine same uv.lock Docker treats this as a completely different cache.\nDifferent target path = different cache volume\nSo these do not share cache:\n/root/.cache/uv ‚ùå /home/vscode/.cache/uv ‚ùå Why Docker Behaves This Way (Important Mental Model) Cache mounts are not filesystem overlays.\nThey are explicit cache volumes, and Docker intentionally isolates them unless you tell it otherwise.\nThe simplified mental model is:\ncache-key = (builder, cache-id OR target-path) If you:\nchange users change home directories change paths ‚Ä¶you‚Äôve implicitly changed the cache key.\nThis design avoids accidental cache corruption, but it means sharing is opt-in, not automatic.\nHow to Force Cache Sharing (The Correct Way) To share cache across users, paths, stages, or images, you must use an explicit cache ID.\nRUN --mount=type=cache,id=uv-cache,target=/root/.cache/uv \\ uv sync Later:\nRUN --mount=type=cache,id=uv-cache,target=/home/vscode/.cache/uv \\ uv sync Now Docker sees:\nSame id=uv-cache Different target paths ‚úÖ Same underlying cache volume This is the intended and supported way to share caches across users (root / non-root), paths, stages, images.\nBest Practice for uv Cache Mounts For uv, the cleanest approach is to standardize the cache directory across images:\nENV UV_CACHE_DIR=/cache/uv RUN --mount=type=cache,id=uv-cache,target=${UV_CACHE_DIR} \\ uv sync This avoids:\nPermission mismatches User home directory confusion Accidental cache fragmentation One Subtle but Critical Detail: Permissions If you share a cache between root and non-root users, permissions matter.\nIf the cache directory isn‚Äôt writable (or at least readable) by both, you‚Äôll see:\npermission denied errors wheels not reused silent cache misses A pragmatic solution during build:\nENV UV_CACHE_DIR=/cache/uv RUN --mount=type=cache,id=uv-cache,target=${UV_CACHE_DIR} \\ chmod -R 0777 /cache/uv || true This ensures the cache remains usable regardless of UID.\nTL;DR Scenario Cache Shared? Different targets, no id ‚ùå No Same target path ‚úÖ Yes Different targets, same id ‚úÖ Yes Different users, same id ‚úÖ Yes Rule of thumb:\nüëâ If you want sharing, always set id explicitly.\nDev Containers Caveat This solution only applies to build-time caches. You cannot use Docker cache mounts as runtime mounts inside containers including dev containers.\nFor example, this will not work:\n// devcontainer.json \"mounts\": [ \"type=cache,id=uv-cache,target=/cache/uv\" ] Cache mounts:\nexist only during docker build do not persist into running containers behave the same for application containers and dev containers How do we benefit from uv cache in dev containers then?\nYou can make cache mounts work when building the dev container, but it requires referencing a custom Dockerfile in devcontainer.json, which adds devops complexity. Personally I prefer a simpler solution to let all dev containers share one uv cache volume using an explicit volume mount at runtime instead.\n// devcontainer.json \"containerEnv\": { \"UV_CACHE_DIR\": \"/uvcache\" }, \"mounts\": [ \"source=${localEnv:UV_CACHE_DIR},target=/uvcache,type=bind,consistency=cached\" ] Though this does not reuse the bulid time cache mount, it ensures all your dev containers reuse the same uv cache volume.\nOne extra cache copy, but simpler, faster, fewer surprises.\n","wordCount":"587","inLanguage":"en","datePublished":"2025-12-15T17:44:20+08:00","dateModified":"2025-12-15T17:44:20+08:00","author":[{"@type":"Person","name":"sidecus"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.hungryfool.net/posts/docker-cache-mount---uv-as-an-example/"},"publisher":{"@type":"Organization","name":"A Hungry Fool","logo":{"@type":"ImageObject","url":"https://www.hungryfool.net/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://www.hungryfool.net/ accesskey=h title="A Hungry Fool (Alt + H)">A Hungry Fool</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.hungryfool.net/archives title=Archive><span>Archive</span></a></li><li><a href=https://www.hungryfool.net/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://www.hungryfool.net/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Docker Cache Mount - uv as an Example</h1><div class=post-meta><span title='2025-12-15 17:44:20 +0800 +0800'>December 15, 2025</span>&nbsp;¬∑&nbsp;<span>3 min</span>&nbsp;¬∑&nbsp;<span>sidecus</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#how-cache-mount-actually-works aria-label="How Cache Mount Actually Works">How Cache Mount Actually Works</a></li><li><a href=#why-docker-behaves-this-way-important-mental-model aria-label="Why Docker Behaves This Way (Important Mental Model)">Why Docker Behaves This Way (Important Mental Model)</a></li><li><a href=#how-to-force-cache-sharing-the-correct-way aria-label="How to Force Cache Sharing (The Correct Way)">How to Force Cache Sharing (The Correct Way)</a></li><li><a href=#best-practice-for-uv-cache-mounts aria-label="Best Practice for uv Cache Mounts">Best Practice for uv Cache Mounts</a></li><li><a href=#one-subtle-but-critical-detail-permissions aria-label="One Subtle but Critical Detail: Permissions">One Subtle but Critical Detail: Permissions</a></li><li><a href=#tldr aria-label=TL;DR>TL;DR</a></li><li><a href=#dev-containers-caveat aria-label="Dev Containers Caveat">Dev Containers Caveat</a></li></ul></div></details></div><div class=post-content><p>Docker‚Äôs <a href=https://docs.docker.com/build/cache/optimize/#use-cache-mounts>cache mount</a> (<code>--mount=type=cache</code>) looks simple on the surface, but it hides an important mental model that often trips people up‚Äîespecially when mixing <strong>root vs non-root users</strong>, <strong>different home directories</strong>, or <strong>multi-stage builds</strong>.</p><p>This post explains <strong>how cache mounts actually work</strong>, <strong>why they don‚Äôt share by default</strong>, and <strong>how to correctly share them</strong>, using <a href=https://docs.astral.sh/uv/concepts/cache/#cache-directory>uv cache</a> as a concrete example.</p><hr><h2 id=how-cache-mount-actually-works>How Cache Mount Actually Works<a hidden class=anchor aria-hidden=true href=#how-cache-mount-actually-works>#</a></h2><p>Consider this Dockerfile instruction:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>RUN</span> --mount<span style=color:#f92672>=</span>type<span style=color:#f92672>=</span>cache,target<span style=color:#f92672>=</span>/root/.cache/uv <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    uv sync<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>When Docker executes this, it creates a <strong>named cache volume</strong>. The cache is keyed by:</p><ol><li>The <strong>builder instance</strong></li><li>The <strong>target path</strong> (<code>/root/.cache/uv</code>)</li><li>An <strong>optional cache ID</strong> (if you provide one)</li></ol><p>Now compare it with:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>RUN</span> --mount<span style=color:#f92672>=</span>type<span style=color:#f92672>=</span>cache,target<span style=color:#f92672>=</span>/home/vscode/.cache/uv <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    uv sync<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>Even if:</p><ul><li>it‚Äôs the same Dockerfile</li><li>same base image</li><li>same machine</li><li>same <code>uv.lock</code></li></ul><p>Docker treats this as a <strong>completely different cache</strong>.</p><p><strong>Different target path = different cache volume</strong></p><p>So these <strong>do not share</strong> cache:</p><ul><li><code>/root/.cache/uv</code> ‚ùå</li><li><code>/home/vscode/.cache/uv</code> ‚ùå</li></ul><hr><h2 id=why-docker-behaves-this-way-important-mental-model>Why Docker Behaves This Way (Important Mental Model)<a hidden class=anchor aria-hidden=true href=#why-docker-behaves-this-way-important-mental-model>#</a></h2><p>Cache mounts are <strong>not filesystem overlays</strong>.</p><p>They are <strong>explicit cache volumes</strong>, and Docker intentionally isolates them unless you tell it otherwise.</p><p>The simplified mental model is:</p><pre tabindex=0><code>cache-key = (builder, cache-id OR target-path)
</code></pre><p>If you:</p><ul><li>change users</li><li>change home directories</li><li>change paths</li></ul><p>‚Ä¶you‚Äôve implicitly changed the cache key.</p><p>This design avoids accidental cache corruption, but it means <strong>sharing is opt-in</strong>, not automatic.</p><hr><h2 id=how-to-force-cache-sharing-the-correct-way>How to Force Cache Sharing (The Correct Way)<a hidden class=anchor aria-hidden=true href=#how-to-force-cache-sharing-the-correct-way>#</a></h2><p>To share cache across users, paths, stages, or images, you must use an <strong>explicit cache ID</strong>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>RUN</span> --mount<span style=color:#f92672>=</span>type<span style=color:#f92672>=</span>cache,id<span style=color:#f92672>=</span>uv-cache,target<span style=color:#f92672>=</span>/root/.cache/uv <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    uv sync<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>Later:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>RUN</span> --mount<span style=color:#f92672>=</span>type<span style=color:#f92672>=</span>cache,id<span style=color:#f92672>=</span>uv-cache,target<span style=color:#f92672>=</span>/home/vscode/.cache/uv <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    uv sync<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>Now Docker sees:</p><ul><li>Same <code>id=uv-cache</code></li><li>Different target paths</li><li>‚úÖ <strong>Same underlying cache volume</strong></li></ul><p>This is the <strong>intended and supported way</strong> to share caches across users (root / non-root), paths, stages, images.</p><hr><h2 id=best-practice-for-uv-cache-mounts>Best Practice for <code>uv</code> Cache Mounts<a hidden class=anchor aria-hidden=true href=#best-practice-for-uv-cache-mounts>#</a></h2><p>For <code>uv</code>, the cleanest approach is to <strong>standardize the cache directory</strong> across images:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>ENV</span> UV_CACHE_DIR<span style=color:#f92672>=</span>/cache/uv<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> --mount<span style=color:#f92672>=</span>type<span style=color:#f92672>=</span>cache,id<span style=color:#f92672>=</span>uv-cache,target<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>UV_CACHE_DIR<span style=color:#e6db74>}</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    uv sync<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>This avoids:</p><ul><li>Permission mismatches</li><li>User home directory confusion</li><li>Accidental cache fragmentation</li></ul><hr><h2 id=one-subtle-but-critical-detail-permissions>One Subtle but Critical Detail: Permissions<a hidden class=anchor aria-hidden=true href=#one-subtle-but-critical-detail-permissions>#</a></h2><p>If you share a cache between <strong>root</strong> and <strong>non-root</strong> users, permissions matter.</p><p>If the cache directory isn‚Äôt writable (or at least readable) by both, you‚Äôll see:</p><ul><li><code>permission denied</code> errors</li><li>wheels not reused</li><li>silent cache misses</li></ul><p>A pragmatic solution during build:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>ENV</span> UV_CACHE_DIR<span style=color:#f92672>=</span>/cache/uv<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> --mount<span style=color:#f92672>=</span>type<span style=color:#f92672>=</span>cache,id<span style=color:#f92672>=</span>uv-cache,target<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>UV_CACHE_DIR<span style=color:#e6db74>}</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    chmod -R <span style=color:#ae81ff>0777</span> /cache/uv <span style=color:#f92672>||</span> true<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>This ensures the cache remains usable regardless of UID.</p><hr><h2 id=tldr>TL;DR<a hidden class=anchor aria-hidden=true href=#tldr>#</a></h2><table><thead><tr><th>Scenario</th><th>Cache Shared?</th></tr></thead><tbody><tr><td>Different targets, no <code>id</code></td><td>‚ùå No</td></tr><tr><td>Same target path</td><td>‚úÖ Yes</td></tr><tr><td>Different targets, same <code>id</code></td><td>‚úÖ Yes</td></tr><tr><td>Different users, same <code>id</code></td><td>‚úÖ Yes</td></tr></tbody></table><p><strong>Rule of thumb:</strong><br>üëâ <em>If you want sharing, always set <code>id</code> explicitly.</em></p><hr><h2 id=dev-containers-caveat>Dev Containers Caveat<a hidden class=anchor aria-hidden=true href=#dev-containers-caveat>#</a></h2><p>This solution only applies to <strong>build-time caches</strong>. You <strong>cannot</strong> use Docker cache mounts as runtime mounts inside containers including dev containers.</p><p>For example, this <strong>will not work</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#75715e>// devcontainer.json
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#e6db74>&#34;mounts&#34;</span><span style=color:#960050;background-color:#1e0010>:</span> [
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;type=cache,id=uv-cache,target=/cache/uv&#34;</span>
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>Cache mounts:</p><ul><li>exist only during <code>docker build</code></li><li>do not persist into running containers</li><li>behave the same for application containers and dev containers</li></ul><p>How do we benefit from uv cache in dev containers then?</p><p>You <em>can</em> make cache mounts work when <strong>building</strong> the dev container, but it requires referencing a <a href=https://code.visualstudio.com/docs/devcontainers/create-dev-container#_dockerfile>custom <code>Dockerfile</code></a> in <code>devcontainer.json</code>, which adds devops complexity.
Personally I prefer a simpler solution to let <strong>all dev containers share one <code>uv</code> cache volume</strong> using an explicit volume mount at runtime instead.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#75715e>// devcontainer.json
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#e6db74>&#34;containerEnv&#34;</span><span style=color:#960050;background-color:#1e0010>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;UV_CACHE_DIR&#34;</span>: <span style=color:#e6db74>&#34;/uvcache&#34;</span>
</span></span><span style=display:flex><span>}<span style=color:#960050;background-color:#1e0010>,</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;mounts&#34;</span><span style=color:#960050;background-color:#1e0010>:</span> [
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;source=${localEnv:UV_CACHE_DIR},target=/uvcache,type=bind,consistency=cached&#34;</span>
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>Though this does not reuse the bulid time cache mount, it ensures all your dev containers reuse the same uv cache volume.</p><p>One extra cache copy, but simpler, faster, fewer surprises.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.hungryfool.net/tags/docker/>Docker</a></li><li><a href=https://www.hungryfool.net/tags/devcontainers/>Devcontainers</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Cache Mount - uv as an Example on x" href="https://x.com/intent/tweet/?text=Docker%20Cache%20Mount%20-%20uv%20as%20an%20Example&amp;url=https%3a%2f%2fwww.hungryfool.net%2fposts%2fdocker-cache-mount---uv-as-an-example%2f&amp;hashtags=docker%2cdevcontainers"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Cache Mount - uv as an Example on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.hungryfool.net%2fposts%2fdocker-cache-mount---uv-as-an-example%2f&amp;title=Docker%20Cache%20Mount%20-%20uv%20as%20an%20Example&amp;summary=Docker%20Cache%20Mount%20-%20uv%20as%20an%20Example&amp;source=https%3a%2f%2fwww.hungryfool.net%2fposts%2fdocker-cache-mount---uv-as-an-example%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Cache Mount - uv as an Example on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.hungryfool.net%2fposts%2fdocker-cache-mount---uv-as-an-example%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.hungryfool.net/>A Hungry Fool</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>